%%% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%%% Next Year:
%%%   * the code examples should be imported from real source files
%%%   * the output results should be generated by the makefile
%%%     from those source files and imported also
%%% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


%&pdflatex
\documentclass{beamer}

\usepackage{115lab}
\usepackage{alltt, amsfonts}

\title[Lab 1]{CMPT 115\\ Principles of Computer Science}
\subtitle[Console and File I/O in procedural C++] {Console and File I/O in C++}
\institute[University of Saskatchewan] {
  Department of Computer Science\\ University of Saskatchewan
}
\author[Chris Dutchyn et. al]{Chris Dutchyn, based on those of Ian McQuillan and Dmytro Dyachuk\\ {\tiny Notes written by Mark Eramian, Ian McQuillan, Dmytro Dyachuk and Matthew Donaldson}}
\date[Lab1] {January 11-15, 2010}

\begin{document}

\maketitle


\part{C++}

\begin{frame}[fragile]
\frametitle{C}

\begin{itemize}
\item In 115 labs, we are using C++, but no object-oriented features.

\item C++ program files should have a ``\texttt{.cc}'' extension and are compiled by \texttt{g++} compiler.  For example:
\begin{center}
\texttt{g++ -Wall printnumbers.cc}
\end{center}
creates an executable program called \texttt{a.out}.
\item You can then run the program by executing ``\texttt{./a.out}''.

\item We use the \texttt{-Wall} flag to ask the compiler for as much checking and warning as possible.
\end{itemize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Our first program}

Here is our first program.  Type it into your favourite editor and save the contents in a file called 
\texttt{base.cc}.

\begin{pseudo}
// Our first C++ program

using namespace std;

#include <cstdlib>

// main program entry point
int main(void) \{
  return EXIT_SUCCESS;
\}
\end{pseudo}

It does nothing except report successful completion.  But, that is enough to serve as a starting point for every other program we design.
\end{frame}

\begin{frame}[fragile]
\frametitle{Our second program}

Here is our second program.  Type it into your favourite editor and save the contents in a file called 
\texttt{hello.cc}.

\begin{pseudo}
// Our second C++ program

using namespace std;

#include <cstdlib>
\textcolor{red}{#include <cstdio>             // added}

// main program entry point
int main(void) \{
\textcolor{red}{  printf("Hello, world!{\bsl}n");  // added}
  return EXIT_SUCCESS;
\}
\end{pseudo}

Notice that we took our first program as a starting point, and added two lines.
\end{frame}


\begin{frame}[fragile]
\frametitle{C++ vs. C}
Most of the procedural C++ we will use is identical to C.
\begin{itemize}
\item variable types - \texttt{int}, \texttt{float}, \texttt{char}, \texttt{double}.
\item \texttt{if} statements, \texttt{for} loops, \texttt{while} loops.

\end{itemize}
\begin{pseudo}
using namespace std;

#include <cstdlib>
#include <cstdio>

int main(void) \{
  int k = 1;
  int l = 10;
  char c = 'X';
  for (k=0; k < l; k++) \{ printf("%i{\bsl}n", k); \}
  printf("%c{\bsl}n", c);
  return EXIT_SUCCESS;
\}
\end{pseudo}

\end{frame}

\begin{frame}[fragile]
\frametitle{differences}

There are some small differences:
\begin{enumerate}

\item line-oriented comments
\item a real boolean (\texttt{true} and \texttt{false}) type (yay!)
\item variables can be declared anywhere in a function, including with limited scope for a loop body
\item input (from console or files),
\item output (to console or to files),
\item C strings are just arrays of characters, rather than object-oriented C++'s class-based strings
\end{enumerate}

\end{frame}


\begin{frame}[fragile,shrink=10]
\frametitle{Differences}
\begin{columns}
\begin{column}{4.8cm}
\begin{block}{C code}
\begin{verbatim}


#include <stdlib.h>
#include <stdio.h>

int main(void) {
   int k = 1, l = 10;
   char c = 'X';
   for(k=0; k < l; k++){ 
      printf("%i\n", k);
   }
   printf("%c\n", c);
   return 0;
}
\end{verbatim}
\end{block}
\end{column}
\begin{column}{5.6cm}
\begin{block}{procedural C++}
\begin{verbatim}
using namespace std;

#include <cstdlib>
#include <cstdio>

int main(void) {
   int l = 10;
   char c = 'X';
   for(int k=0; k < l; k++){ 
      printf("%i\n", k);
   }
   printf("%c\n", c);
   return EXIT_SUCCESS;
}
\end{verbatim}
\end{block}
\end{column}
\end{columns}

\begin{itemize}
\item Try to run each of these programs with \texttt{gcc}?  What happens?
\item Then, try to run each with \texttt{g++}?  What happens?
\end{itemize}

\end{frame}


\part{Console I/O}
\frame{\partpage}

\begin{frame}
  \frametitle{Console I/O}
  \begin{itemize}
  \item
    Console I/O is input from the keyboard, and output to the computer's display.
   \item We examine the procedural C++ equivalents to \texttt{cin} and \texttt{cout} from object-oriented C++.
   \item These procedural C++ functions also work in C.
  \end{itemize}
\end{frame}

\section{Using \texttt{printf}}
\begin{frame}[fragile,shrink=10]
	\frametitle{Using \texttt{printf}}
	\begin{itemize}
	\item To use I/O functions in procedural C++, we must include the correct header file (analgous to \texttt{\#include <iostream>} in object-oriented C++):
		\begin{center} \texttt{\#include <cstdio>} \end{center}
	\item The output function \texttt{printf} performs the same task as \texttt{cout}... printing character strings and the values of variables to the screen.  
	\item A program using \texttt{printf} in its simplest form:
\end{itemize}
\begin{pseudo}
#include <cstdlib>
#include <cstdio>

int main(void) \{
    printf("Hello world.{\bsl}n");
    return EXIT_SUCCESS;
\}
\end{pseudo}
\begin{itemize}
\item 
Note the `escape sequence' \texttt{\bsl n} is used to print a newline.
\item Try it, changing the number of newlines to $0$ and $2$.

\end{itemize}

\end{frame}

\section{Format Specifiers}

\begin{frame}[fragile]
\frametitle{Printing Variables}
\begin{itemize}
\item To print the value of an integer variable:
\begin{pseudo}
#include <cstdlib>
#include <cstdio>

int main(void) \{
    int a = 5;
    printf("\%i{\bsl}n", a);
    printf("The value of a is: \%i{\bsl}n", a);
    return EXIT_SUCCESS;
\}
\end{pseudo}
\item The output of this program is:
\begin{pseudo}
5
The value of a is: 5
\end{pseudo}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{The Format String}
\begin{itemize}
\item In general, the \texttt{printf} function takes one or more parameters.
\item The first parameter is always the \textit{format string}.  
\item The format string is printed to the screen.
\item If the format string contains a \textit{format specifier} (e.g. \texttt{\%i}) then the additional parameters are matched with the format specifiers which cause the value of the corresponding variable to be printed.
\item Format specifiers are matched with additional parameters in the order they are given:
\begin{pseudo}
#include <cstdlib>
#include <cstdio>

int main(void) \{
    int a = 5, b = 10;
    printf("a is: \%i and b is: \%i.{\bsl}n", a, b);
    return EXIT_SUCCESS;
\}
\end{pseudo}
\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Format Specifiers}
	\begin{itemize}
	\item A different format specifier is used depending on the type of variable that is to be printed:\\
		\mbox{}\\
	\begin{block}{}
	\begin{tabular}{clp{2in}}
	Specifier& Data Type& Description\\\hline
   	\texttt{\%d} or \texttt{\%i}&   \texttt{int}& decimal integer\\
   	\texttt{\%c}&  \texttt{char}& single character\\
   	\texttt{\%s}&   \texttt{char* }& string\\
   	\texttt{\%f}&   \texttt{float} or \texttt{double}& floating-point number \\
   	\texttt{\%u}&   \texttt{unsigned int}& unsigned decimal integer
	\end{tabular}
	\end{block}
	\item Pairing a format specifier with a variable of the wrong data type can lead to bizarre, inexplicable output.

	\end{itemize}
	
\end{frame}

\begin{frame}[fragile]
\frametitle{Example:}
This code fragment:
\begin{pseudo}
int a = 5;
float b = 10.0;
printf("\%d, \%f{\bsl}n", a, b);  
\end{pseudo}
prints this:
\begin{pseudo}
5, 10.000000
\end{pseudo}
\end{frame}

\begin{frame}[fragile]
This code fragment:
\begin{pseudo}
// Observe we can also print literals, as well as variables.
printf("The answer to life, the universe and everything is: \%d.{\bsl}n",
        42);

// We can also print the results of expressions:
unsigned nc = 52;
unsigned nd = 3;
printf("There are \%u cards in \%u decks of cards.{\bsl}n", nd*nc, nd);
\end{pseudo}
prints this:
\begin{pseudo}
The answer to life, the universe and everything is: 42.
There are 156 cards in 3 decks of cards.
\end{pseudo}

\end{frame}



\begin{frame}
\frametitle{Using Format Specifiers}
\begin{itemize}
 \item  You can obtain further control by using modifiers. 
\item For example, you can add a numeric prefix to specify the minimum field width:\\
					\begin{center} \texttt{\%10d}\\ \end{center}
\item   This specifies a minimum field width of ten characters. If the printed value has fewer characters/digits than the number specified, it will be padded with blanks so that at least 10 characters are printed.
		      
 \item This is  useful to format output in a pretty way.
\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Using Format Specifiers cont'd}
	\begin{itemize}
		\item Adding a minus sign:\\ 
					\begin{center} \texttt{\%-10d}\\ \end{center}
		   	This causes the text to be left-justified.
		\item You can also add a numeric precision:\\ 
					\begin{center} \texttt{\%6.3f}\\ \end{center}
			   This specifies three digits of precision in a field six characters wide. 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Format Specifiers Example}
	Example:
	\begin{pseudo}
     printf( "<\%d>{\bsl}n", 336 );
     printf( "<\%2d>{\bsl}n", 336 );
     printf( "<\%10d>{\bsl}n", 336 );
     printf( "<\%-10d>{\bsl}n", 336 );
     return EXIT_SUCCESS;
	\end{pseudo}
	This prints:
	\begin{pseudo}	
   <336>
   <336>
   <       336>
   <336       >
	\end{pseudo}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Format Specifiers Example}
	Similarly,
	\begin{pseudo}
   #include <cstdio>
   void main(void) \{
     printf( "<\%f>{\bsl}n", 1234.56 );
     printf( "<\%4.2f>{\bsl}n", 1234.56 );
     printf( "<\%10.3f>{\bsl}n", 1234.56 );
   \}
	\end{pseudo}
	prints:\\
	\begin{pseudo}	
   <1234.560000>
   <1234.56>
   <  1234.560>
	\end{pseudo}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exercise}
Given the variable declarations:
\begin{pseudo}
int x = 12;
unsigned y = 6;
float z = 2.0;
\end{pseudo}
write a procedural C++ program to print out the value of these variables.
\vspace{1em}

\end{frame}


\begin{frame}[fragile]
\frametitle{A Potential Pitfall}
\begin{itemize}
\item Output from \texttt{printf} is \textit{buffered} -- this means that the operating system does not actually print characters to the screen until \texttt{printf} sends a newline.
\item this can cause much confusion when debugging -- you might think the program is crashing earlier than it really is if you printed a line of text without a newline, you might think that line never executed even though it did.
\item To be safe, always end your \texttt{printf} calls with a newline when possible.
\end{itemize}
\end{frame}


\section{Using scanf}
\begin{frame}
	\frametitle{Using scanf}
	\begin{itemize}
		\item The function \texttt{scanf} is the input analog of \texttt{printf}.
		\item It's syntax is very similar to that of \texttt{printf} except that format specifiers in the format string instruct \texttt{scanf} to read values from the keyboard and store them in the corresponding variables.

		\item The other arguments, indicate where the
			corresponding converted input should be stored.
		\item \texttt{scanf} returns the number of successfully matched and assigned input items
			(can be used to decide how many items were found). 
	\end{itemize}
\end{frame}



\section{Examples}
\begin{frame}[fragile,shrink=10]
	\frametitle{scanf Example}
	Example:
	\begin{verbatim}
        using namespace std;
        #include <cstdlib>
        #include <cstdio>
        int main(void) {
          int val;
          char name[256];

          printf("Enter your age and name.\n");
          scanf("%d %s", &val, name); 
          printf("Your name is: %s, your age is: %d\n", name, val);
          return EXIT_SUCCESS;
        }
   \end{verbatim}
\begin{itemize}
\item    For reasons that will become clear after section 3 of the lectures, when listing the variables in scanf, we must prefix all of the with \& symbol, except for strings.
\item We list the integer \verb|val| with \& before, but not so with \verb|name| since it is a string.

\end{itemize}
   
\end{frame}

\begin{frame}[fragile,shrink=10]
	\frametitle{Another scanf Example}
	\begin{verbatim}
  using namespace std;
  #include <cstdlib>
  #include <cstdio>
  int main(void) {
     int i;
     float fp;
     char c, s[81];
     printf("Enter an integer, a real number, ");
     printf("a character, and a string: \n");
     if (scanf("%d %f %c %s", &i, &fp, &c, s) != 4) {
        printf("Not all fields were assigned\n");
     } else {
        printf("integer = %d\n", i);
        printf("real number = %f\n", fp);
        printf("character = %c\n", c);
        printf("string = %s\n",s);
     }
     return EXIT_SUCCESS;
  }
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Another scanf Example cont'd}
If input is:
\[ \texttt{12 2.5 a yes}\]
then output should be similar to: 
	\begin{verbatim} 
Enter an integer, a real number, a character and a string:
integer = 12
real number = 2.500000
character = a
string = yes

\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{When do I use the \texttt{\&} with scanf?}
\begin{itemize}
\item Let us emphasize that when using \texttt{scanf} to read values into variables, you \textbf{must} precede the variable name with an \texttt{\&} \textit{unless it is the name of an array} (character strings are arrays!).
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Exercise:}
Write a program that prompts a user to enter their first name, and year of birth.  Print a message saying that the user is lucky if their year of birth is evenly divisible by 5.

A sample run:
\begin{pseudo}
Enter your name:  {\color{red} John}
Enter your year of birth: {\color{red} 1985}

You are very lucky, John!
\end{pseudo}
(text in red is entered by the user at runtime)
\end{frame}


\part{File I/O}
\frame{\partpage}

\section{File Streams}

\begin{frame}
	\frametitle{File Streams}
	\begin{itemize}
	\item File I/O is abstracted in procedural C++ through the notion of a \textit{file stream}. 
   \item Two kinds of file streams:
   \begin{itemize}
   	\item Text streams - stream of characters.
   	\item Binary streams - streams of bytes.
	\end{itemize}
	\item We'll only look at text streams in this course.
	
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{File Streams cont'd}
	\begin{itemize}
	\item Files must be \textit{opened} before they can be accessed.
	\item Files must be \textit{closed} when one is done with them. Failure to do so can cause incomplete output when the buffer is not flushed before program termination.
   \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{File I/O in C}
	\begin{itemize}
	\item The C++ library, \texttt{cstdio}, supplies the following functions for reading/writing files:
		 \begin{tabular}[h]{l l}
 	   	\texttt{fopen()}  & Open a file \\
 		  \texttt{fclose()} & Close a file (important when writing!)\\
			\texttt{fprintf()}& Print to \textit{text} stream like \texttt{printf()}\\
			\texttt{fscanf()} & Read from \textit{text} stream like \texttt{scanf()}\\
			\texttt{feof()}   & Returns true if \textit{end-of-file} is reached\\
			\texttt{fgets()}  & Read a line of text from a \textit{text} stream.\\
 		 \end{tabular}
	\item Other functions are used for binary streams.
	\end{itemize}
\end{frame}

\section{File Handles}
\begin{frame}
	\frametitle{File handles}
	\begin{itemize}
		\item An open file is manipulated through a \textit{file handle}.
		\item A file handle has type \texttt{FILE* } (defined in \texttt{cstdio}).
		\item \texttt{FILE* } is an abstraction of the file stream.
   \end{itemize}
\end{frame}

\section{Opening Text Files}
\begin{frame}
	\frametitle{Opening a file}
	\begin{itemize}
		\item \texttt{FILE* fopen(const char* path, const char* mode);}
			\texttt{path} - string containing the filename.
			\texttt{mode} - type of stream desired
		\item All that means is that the first parameter is the file name of the file you want to open, and	
		\item the second is a sequence of some of the following 3 letters depending on what you want to do with the file.
			\begin{tabular}[h]{l l}
  				\texttt{r}   & Open for reading.\\
  				\texttt{w}   & Open and wipe (or create) for writing.\\
  				\texttt{a}   & Append -- open (or create) to write to end of file.\\
   		\end{tabular}
		\item \texttt{fopen()} returns a special pointer called \texttt{NULL} on error, or pointer to new file handle if
			successful.
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Opening a file cont'd}
	Example of opening a file for reading:\\
	\begin{verbatim}
using namespace std;
#include <cstdlib>
#include <cstdio>
int main(void) {
  FILE* infile;  //you need the * here
  infile = fopen("foo.dat", "r");//name of file is 'foo.dat'.  
                         //The 'r' means we will read file.
  if(infile == NULL) { //this will be true if there was an 
    perror("fopen failed"); //error such as file not existing
    return EXIT_FAILURE;
  }
  //... This is where we read each line of the file.
  printf("File opened successfully.\n");
  return EXIT_SUCCESS;
}
	\end{verbatim}
\end{frame}

\section{Writing to a File}
\begin{frame}
	\frametitle{Writing to a text stream}
	\begin{itemize}
		\item \texttt{int fprintf(FILE* stream, const char* format, ...);}
		\item Works exactly like \texttt{printf} except it has an additional first parameter which is a file handle.
		\item C++ defines automatically three special file handles as global variables:\\
			\indent \texttt{stdin} - keyboard\\
			\indent \texttt{stdout} - screen\\
			\indent \texttt{stderr} - stream, but unbuffered!
		\item Thus \texttt{fprintf(stdout, "foo$\backslash$n");} is the same as \texttt{printf("foo$\backslash$n");}.
		\item Use \texttt{fprintf(stderr, ...);} to print to the screen immediately, without buffering.  Good for debugging statements.
   \end{itemize}
\end{frame}

\begin{frame}[fragile,shrink=20]
	\frametitle{Writing to a Text Stream}
	\begin{verbatim}
using namespace std;
#include <cstdlib>
#include <cstdio>
#include <cstring>
// Write characters in a string to a file, one per line
int main(void) {
   FILE* outfile;  // file handle
   char s[256];    // holds a string
   int i;          // loop counter
   
   printf("\nenter a string:");
   scanf("%s",s); //reads in a string from the user
   outfile = fopen("out.dat", "w"); //opens the file out.dat to write to
   if(outfile == NULL) { perror("fopen failed"); return EXIT_FAILURE; }
   for(i=0; i < strlen(s); i++) //strlen(s) is the length of the string
      fprintf(outfile, "%c\n", s[i]); //print each character to the file.
   fclose(outfile);   //close file when done.
   return EXIT_SUCCESS;
}
	\end{verbatim}
	Try out this example, and look inside the file out.dat (open it in an editor).
\end{frame}

\section{Closing a file}
\begin{frame}
	\frametitle{Closing a File}
	\begin{itemize}
		\item \texttt{int fclose(FILE* stream);}
		\item Closes the open file and frees any memory associated with the file
			descriptor \texttt{stream}.
		\item If \texttt{stream} is writable, any buffered writes get flushed to the disk
			before the file is closed.
		\item Failure to close a file before program termination can result in data being lost.
   \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Detecting End of File}
	\begin{itemize}
		\item \texttt{int feof(FILE* stream);}
		\item Returns a nonzero integer if end of file has been reached during the previous file operation.
		\item If end of file has not been reached, 0 is returned.
		\item Result is only valid if performed after another file operation such as \texttt{fprintf} or \texttt{fscanf} -- indicates whether the previous operation encountered end of file.
   \end{itemize}
\end{frame}

\section{Reading from a File}
\begin{frame}
	\frametitle{Reading from a Text Stream}
	\begin{itemize}
		\item \texttt{int fscanf(FILE* stream, const char* format, ...);}
		\item Works exactly like \texttt{scanf()} except the first argument is a file handle.
			Opposite of \texttt{fprintf()}.
		\item Remember, target variables must be pointers.
		\item Example: Read a string (up to the next whitespace character) from
			the file stream 'infile':\\
			\texttt{fscanf(infile, "\%s", s);}
   \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Reading from a Text Stream cont'd}
	\begin{itemize}
		\item Whitespace characters in the format string match any number of
			whitespace characters (including no whitespace).
		\item Input stops if a character in the format string fails to match, or a
		format specifier cannot be matched by data from the stream.
		\item \texttt{\%f} can only be used to read a \texttt{float}.
		\item Use \texttt{\%lf} to read a \texttt{double}.
		\item The above points also hold for \texttt{scanf()}.
		\item If file contains:\\
			size: 15\\
			then\\
			\texttt{fscanf(infile, "size: \%i", \&myInt);}\\
			stores the value 15 into integer myInt.
   \end{itemize}
\end{frame}


\section{More Examples}

\begin{frame}[fragile]
	\frametitle{More Examples}
	{\scriptsize 
	\begin{verbatim}
using namespace std;
#include <cstdlib>
#include <cstdio>
int main (void) {
  char let_1, let_2, let_3; // three letters 
  int year; // current year 
  FILE* outp; // output file
  
  outp = fopen("output.txt", "w");
  printf("Enter a 3-letter nickname and press return> ");
  scanf("%c%c%c", &let1, &let2, &let3);
  printf("Enter the current year and press return> ");
  scanf("%d", &year);
  printf("Welcome, %c%c%c. %d is a great year to study C!\n",
         let_1, let_2, let_3, year);
  fprintf (outp, "%c%c%c", let1, let2, let3);
  
  fclose(outp);
  return EXIT_SUCCESS;
}	
	\end{verbatim}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{More Examples cont'd}
	{\small
	PROGRAM OUTPUT:
	\begin{verbatim}
Enter a 3-letter nickname and press return> Bob
Enter the current year and press return> 2007
Welcome, Bob. 2007 is a great year to study C!
\end{verbatim}}
\vspace{1em}
The program also outputs the 3 characters to a data file \texttt{output.txt}. 	
\end{frame}


\frame{
\frametitle{Exercise:}
Create a text file \texttt{input.txt} that contains two integers.

Write a program that reads in the numbers from \texttt{input.txt} and writes their sum to a file called \texttt{sum.txt}.
}


\end{document}

